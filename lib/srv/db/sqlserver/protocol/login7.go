package protocol

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"net"
	"unicode/utf16"

	"github.com/gravitational/trace"
)

type Login7Packet struct {
	Packet   Packet
	Fields   Login7PacketFields
	Data     []byte
	User     string
	Database string
}

type Login7PacketFields struct {
	Length        uint32
	TDSVersion    uint32
	PacketSize    uint32
	ClientProgVer uint32
	ClientPID     uint32
	ConnectionID  uint32

	OptionFlags1 uint8
	OptionFlags2 uint8
	TypeFlags    uint8
	OptionFlags3 uint8

	ClientTimezone int32
	ClientLCID     uint32

	IbHostName        uint16
	CchHostName       uint16
	IbUserName        uint16
	CchUserName       uint16
	IbPassword        uint16
	CchPassword       uint16
	IbAppName         uint16
	CchAppName        uint16
	IbServerName      uint16
	CchServerName     uint16
	IbUnused          uint16
	CbUnused          uint16
	IbCltIntName      uint16
	CchCltIntName     uint16
	IbLanguage        uint16
	CchLanguage       uint16
	IbDatabase        uint16 // offset
	CchDatabase       uint16 // length
	ClientID          [6]byte
	IbSSPI            uint16
	CbSSPI            uint16
	IbAtchDBFile      uint16
	CchAtchDBFile     uint16
	IbChangePassword  uint16
	CchChangePassword uint16
	CbSSPILong        uint32
}

func ReadLogin7Packet(conn net.Conn) (*Login7Packet, error) {
	pkt, err := ReadPacket(conn)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	fmt.Printf("==> Parsing LOGIN7 packet length: %v\n", pkt.PacketHeader.Length)
	if pkt.Type != PacketTypeLogin7 {
		return nil, trace.BadParameter("expected LOGIN7 packet, got: %#v", pkt)
	}
	var fields Login7PacketFields
	buf := bytes.NewBuffer(pkt.Data)
	err = binary.Read(buf, binary.LittleEndian, &fields)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	p := &Login7Packet{
		Fields: fields,
		Data:   buf.Bytes(), // Remaining unread portion of buffer is the login7 data.
	}
	p.Database, err = ucs22str(pkt.Data[p.Fields.IbDatabase : p.Fields.IbDatabase+p.Fields.CchDatabase*2])
	if err != nil {
		return nil, trace.Wrap(err)
	}
	p.User, err = ucs22str(pkt.Data[p.Fields.IbUserName : p.Fields.IbUserName+p.Fields.CchUserName*2])
	if err != nil {
		return nil, trace.Wrap(err)
	}
	return p, nil
}

func WriteLogin7Response(conn net.Conn, db string) error {
	login7 := &Login7Response{
		Tokens: []Token{
			&EnvChangeDatabaseToken{
				New: db,
				Old: db,
			},
			&EnvPacketSizeToken{
				New: "4096",
				Old: "4096",
			},
			&EnvSQLCollationToken{},
			&LoginAckToken{
				Interface:  1,
				TDSVersion: verTDS74,
				ProgName:   "Teleport",
				ProgVer:    0,
			},
			&DoneToken{},
		},
	}

	data, err := login7.Tokens.Marshal()
	if err != nil {
		return trace.Wrap(err)
	}

	header := []byte{
		PacketTypeResponse, // type
		0x1,                // status - mark as last
		0, 0,               // length
		0, 0,
		0, // packet ID
		0,
	}

	// Update packet length.
	binary.BigEndian.PutUint16(header[2:], uint16(len(data)+8))

	pkt := append(header, data...)

	//pkt = login7Bytes2

	fmt.Println("=== SENT LOGIN7 PACKET ===")
	fmt.Println(hex.Dump(pkt))
	fmt.Println("=======================")

	// Write packet to connection.
	_, err = conn.Write(pkt)
	if err != nil {
		return trace.Wrap(err)
	}

	return nil
}

type Login7Response struct {
	PacketHeader
	Tokens Tokens
}

type Tokens []Token

func (t Tokens) Marshal() ([]byte, error) {
	var b []byte
	for _, tt := range t {
		bb, err := tt.Marshal()
		if err != nil {
			return nil, trace.Wrap(err)
		}
		b = append(b, bb...)
	}
	return b, nil
}

type Token interface {
	Marshal() ([]byte, error)
}

type EnvChangeDatabaseToken struct {
	New string
	Old string
}

func (t *EnvChangeDatabaseToken) Marshal() ([]byte, error) {
	length := 1 + 1 + len(t.New)*2 + 1 + len(t.Old)*2

	b := bytes.NewBuffer(make([]byte, 0, 1+2+length))

	// Token type.
	b.WriteByte(envChangeTokenType)

	// Length.
	binary.Write(b, binary.LittleEndian, uint16(length))

	// Database change.
	b.WriteByte(envChangeDatabase)

	// New value.
	newVal := str2ucs2(t.New)
	binary.Write(b, binary.LittleEndian, uint8(len(newVal)/2))
	b.Write(newVal)

	// Old value.
	oldVal := str2ucs2(t.Old)
	binary.Write(b, binary.LittleEndian, uint8(len(oldVal)/2))
	b.Write(oldVal)

	bytes := b.Bytes()

	fmt.Println("=== ENV CHANGE TOKEN ===")
	fmt.Println(hex.Dump(bytes))
	fmt.Println("=======================")

	return bytes, nil
}

type EnvPacketSizeToken struct {
	New string
	Old string
}

func (t *EnvPacketSizeToken) Marshal() ([]byte, error) {
	length := 1 + 1 + len(t.New)*2 + 1 + len(t.Old)*2

	b := bytes.NewBuffer(make([]byte, 0, 1+2+length))

	// Token type.
	b.WriteByte(envChangeTokenType)

	// Length.
	binary.Write(b, binary.LittleEndian, uint16(length))

	// Database change.
	b.WriteByte(envChangePacketSize)

	// New value.
	newVal := str2ucs2(t.New)
	binary.Write(b, binary.LittleEndian, uint8(len(newVal)/2))
	b.Write(newVal)

	// Old value.
	oldVal := str2ucs2(t.Old)
	binary.Write(b, binary.LittleEndian, uint8(len(oldVal)/2))
	b.Write(oldVal)

	bytes := b.Bytes()

	fmt.Println("=== ENV PACKET SIZE ===")
	fmt.Println(hex.Dump(bytes))
	fmt.Println("=======================")

	return bytes, nil
}

type EnvSQLCollationToken struct {
}

func (t *EnvSQLCollationToken) Marshal() ([]byte, error) {
	return []byte{
		0xE3, 0x08, 0x00, 0x07, 0x05, 0x09, 0x04, 0xD0, 0x00, 0x34, 0x00,
	}, nil
}

type LoginAckToken struct {
	Interface  uint8
	TDSVersion uint32
	ProgName   string
	ProgVer    uint32
}

func (t *LoginAckToken) Marshal() ([]byte, error) {
	length := 1 + 4 + len(t.ProgName)*2 + 4

	// Type + length + data.
	b := bytes.NewBuffer(make([]byte, 0, 1+2+length))

	// Token type.
	b.WriteByte(loginAckTokenType)

	// Token length.
	binary.Write(b, binary.LittleEndian, uint16(length))

	// Interface.
	b.WriteByte(t.Interface)

	// TDS version.
	binary.Write(b, binary.BigEndian, t.TDSVersion)

	// Program name.
	progName := str2ucs2(t.ProgName)
	binary.Write(b, binary.LittleEndian, uint8(len(progName)/2))
	b.Write(progName)

	// Program version.
	binary.Write(b, binary.LittleEndian, t.ProgVer)

	bytes := b.Bytes()

	fmt.Printf("--> Marshaled LoginAck token: %#v\n", bytes)

	return bytes, nil
}

type DoneToken struct {
	Status   uint16
	CurCmd   uint16
	RowCount uint64
}

func (t *DoneToken) Marshal() ([]byte, error) {
	b := bytes.NewBuffer(make([]byte, 0, 1+2+2+8))

	// Token type.
	b.WriteByte(doneTokenType)

	// Status.
	binary.Write(b, binary.LittleEndian, t.Status)

	// Current command.
	binary.Write(b, binary.LittleEndian, t.CurCmd)

	// Row count.
	binary.Write(b, binary.LittleEndian, t.RowCount)

	bytes := b.Bytes()

	fmt.Printf("--> Marshaled Done token: %#v\n", bytes)

	return bytes, nil
}

const (
	envChangeTokenType  uint8 = 0xE3
	envChangeDatabase   uint8 = 0x01
	envChangePacketSize uint8 = 0x04
	loginAckTokenType   uint8 = 0xAD
	doneTokenType       uint8 = 0xFD
)

// convert Go string to UTF-16 encoded []byte (littleEndian)
// done manually rather than using bytes and binary packages
// for performance reasons
func str2ucs2(s string) []byte {
	res := utf16.Encode([]rune(s))
	ucs2 := make([]byte, 2*len(res))
	for i := 0; i < len(res); i++ {
		ucs2[2*i] = byte(res[i])
		ucs2[2*i+1] = byte(res[i] >> 8)
	}
	return ucs2
}

func ucs22str(s []byte) (string, error) {
	if len(s)%2 != 0 {
		return "", fmt.Errorf("illegal UCS2 string length: %d", len(s))
	}
	buf := make([]uint16, len(s)/2)
	for i := 0; i < len(s); i += 2 {
		buf[i/2] = binary.LittleEndian.Uint16(s[i:])
	}
	return string(utf16.Decode(buf)), nil
}

var login7Bytes = []byte{0x4, 0x1, 0x1, 0xba, 0x0, 0x33, 0x1, 0x0, 0xe3, 0x1b, 0x0, 0x1, 0x6, 0x6d, 0x0, 0x61, 0x0, 0x73, 0x0, 0x74, 0x0, 0x65, 0x0, 0x72, 0x0, 0x6, 0x6d, 0x0, 0x61, 0x0, 0x73, 0x0, 0x74, 0x0, 0x65, 0x0, 0x72, 0x0, 0xab, 0x6a, 0x0, 0x45, 0x16, 0x0, 0x0, 0x2, 0x0, 0x25, 0x0, 0x43, 0x0, 0x68, 0x0, 0x61, 0x0, 0x6e, 0x0, 0x67, 0x0, 0x65, 0x0, 0x64, 0x0, 0x20, 0x0, 0x64, 0x0, 0x61, 0x0, 0x74, 0x0, 0x61, 0x0, 0x62, 0x0, 0x61, 0x0, 0x73, 0x0, 0x65, 0x0, 0x20, 0x0, 0x63, 0x0, 0x6f, 0x0, 0x6e, 0x0, 0x74, 0x0, 0x65, 0x0, 0x78, 0x0, 0x74, 0x0, 0x20, 0x0, 0x74, 0x0, 0x6f, 0x0, 0x20, 0x0, 0x27, 0x0, 0x6d, 0x0, 0x61, 0x0, 0x73, 0x0, 0x74, 0x0, 0x65, 0x0, 0x72, 0x0, 0x27, 0x0, 0x2e, 0x0, 0x9, 0x73, 0x0, 0x71, 0x0, 0x6c, 0x0, 0x73, 0x0, 0x65, 0x0, 0x72, 0x0, 0x76, 0x0, 0x65, 0x0, 0x72, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xe3, 0x8, 0x0, 0x7, 0x5, 0x9, 0x4, 0xd0, 0x0, 0x34, 0x0, 0xe3, 0x17, 0x0, 0x2, 0xa, 0x75, 0x0, 0x73, 0x0, 0x5f, 0x0, 0x65, 0x0, 0x6e, 0x0, 0x67, 0x0, 0x6c, 0x0, 0x69, 0x0, 0x73, 0x0, 0x68, 0x0, 0x0, 0xab, 0x6e, 0x0, 0x47, 0x16, 0x0, 0x0, 0x1, 0x0, 0x27, 0x0, 0x43, 0x0, 0x68, 0x0, 0x61, 0x0, 0x6e, 0x0, 0x67, 0x0, 0x65, 0x0, 0x64, 0x0, 0x20, 0x0, 0x6c, 0x0, 0x61, 0x0, 0x6e, 0x0, 0x67, 0x0, 0x75, 0x0, 0x61, 0x0, 0x67, 0x0, 0x65, 0x0, 0x20, 0x0, 0x73, 0x0, 0x65, 0x0, 0x74, 0x0, 0x74, 0x0, 0x69, 0x0, 0x6e, 0x0, 0x67, 0x0, 0x20, 0x0, 0x74, 0x0, 0x6f, 0x0, 0x20, 0x0, 0x75, 0x0, 0x73, 0x0, 0x5f, 0x0, 0x65, 0x0, 0x6e, 0x0, 0x67, 0x0, 0x6c, 0x0, 0x69, 0x0, 0x73, 0x0, 0x68, 0x0, 0x2e, 0x0, 0x9, 0x73, 0x0, 0x71, 0x0, 0x6c, 0x0, 0x73, 0x0, 0x65, 0x0, 0x72, 0x0, 0x76, 0x0, 0x65, 0x0, 0x72, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xad, 0x36, 0x0, 0x1, 0x74, 0x0, 0x0, 0x4, 0x16, 0x4d, 0x0, 0x69, 0x0, 0x63, 0x0, 0x72, 0x0, 0x6f, 0x0, 0x73, 0x0, 0x6f, 0x0, 0x66, 0x0, 0x74, 0x0, 0x20, 0x0, 0x53, 0x0, 0x51, 0x0, 0x4c, 0x0, 0x20, 0x0, 0x53, 0x0, 0x65, 0x0, 0x72, 0x0, 0x76, 0x0, 0x65, 0x0, 0x72, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x7, 0xd0, 0xe3, 0x13, 0x0, 0x4, 0x4, 0x38, 0x0, 0x30, 0x0, 0x30, 0x0, 0x30, 0x0, 0x4, 0x34, 0x0, 0x30, 0x0, 0x39, 0x0, 0x36, 0x0, 0xae, 0x1, 0x2e, 0x0, 0x0, 0x0, 0x0, 0x9, 0x0, 0x60, 0x81, 0x14, 0xff, 0xe7, 0xff, 0xff, 0x0, 0x2, 0x2, 0x7, 0x1, 0x4, 0x1, 0x0, 0x5, 0x4, 0xff, 0xff, 0xff, 0xff, 0x6, 0x1, 0x0, 0x7, 0x1, 0x2, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

var login7Bytes2 = []byte{
	0x04, 0x01, 0x01, 0x61, 0x00, 0x00, 0x01, 0x00, 0xE3, 0x1B, 0x00, 0x01, 0x06, 0x6D, 0x00, 0x61,
	0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x06, 0x6D, 0x00, 0x61, 0x00, 0x73, 0x00,
	0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0xAB, 0x58, 0x00, 0x45, 0x16, 0x00, 0x00, 0x02, 0x00, 0x25,
	0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20,
	0x00, 0x64, 0x00, 0x61, 0x00, 0x74, 0x00, 0x61, 0x00, 0x62, 0x00, 0x61, 0x00, 0x73, 0x00, 0x65,
	0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74,
	0x00, 0x20, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00, 0x27, 0x00, 0x6D, 0x00, 0x61, 0x00, 0x73,
	0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x27, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xE3, 0x08, 0x00, 0x07, 0x05, 0x09, 0x04, 0xD0, 0x00, 0x34, 0x00, 0xE3, 0x17, 0x00, 0x02,
	0x0A, 0x75, 0x00, 0x73, 0x00, 0x5F, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69,
	0x00, 0x73, 0x00, 0x68, 0x00, 0x00, 0xE3, 0x13, 0x00, 0x04, 0x04, 0x34, 0x00, 0x30, 0x00, 0x39,
	0x00, 0x36, 0x00, 0x04, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x36, 0x00, 0xAB, 0x5C, 0x00, 0x47,
	0x16, 0x00, 0x00, 0x01, 0x00, 0x27, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67,
	0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x75,
	0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x20, 0x00, 0x73, 0x00, 0x65, 0x00, 0x74, 0x00, 0x74,
	0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00, 0x75,
	0x00, 0x73, 0x00, 0x5F, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x73,
	0x00, 0x68, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x36, 0x00, 0x01, 0x72,
	0x09, 0x00, 0x02, 0x16, 0x4D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73, 0x00,
	0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x20, 0x00, 0x53, 0x00, 0x51, 0x00, 0x4C, 0x00, 0x20, 0x00,
	0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00}
